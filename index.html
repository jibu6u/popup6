<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Single‑Sphere Binocular Trainer — VR 거리 조절 통합본</title>
<style>
  :root{--bg:#0a0f14;--fg:#e7f0ff;--muted:#9fb3c7;--card:#121821}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,Helvetica,Arial,sans-serif}
  #ui{position:fixed;left:10px;top:10px;background:#121821cc;padding:10px;border-radius:12px;border:1px solid #223449;max-width:980px;z-index:20;max-height:calc(100vh - 20px);overflow:auto}
  #ui label{display:flex;gap:8px;align-items:center;font-size:13px;margin:6px 0}
  #ui input[type=range]{width:100%}
  #ui input[type=number]{width:90px}
  #ui button,#ui select{background:#182536;color:var(--fg);border:1px solid #2b435f;border-radius:8px;padding:6px 8px;cursor:pointer}
  #ui button:hover{background:#1f3046}
  #hud{position:fixed;left:10px;bottom:10px;background:#0009;padding:6px 8px;border-radius:10px;font-size:12px;z-index:19}
  #sbsLabels{position:fixed;top:8px;left:0;right:0;display:flex;justify-content:space-between;pointer-events:none;z-index:18}
  .pill{background:#0009;border:1px solid #335;padding:4px 8px;border-radius:999px;font-size:12px}
  .pill.L{margin-left:12%;color:#ffb3b3;border-color:#553}
  .pill.R{margin-right:12%;color:#b3e6ff;border-color:#355}
  canvas#webgl{display:block;width:100vw;height:100vh}
  #popControls{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
  #popStatus{flex:0 0 72px;width:72px;height:30px;display:flex;align-items:center;justify-content:center;font-weight:700;border-radius:8px;background:#072029;color:#7bd1ff;border:1px solid #0b3e4a;font-size:12px;box-sizing:border-box}
  .muted{color:var(--muted);font-size:12px}
  .small{font-size:12px}
  .upload-list{font-size:12px;color:var(--muted);margin-top:4px}
  .col{display:flex;flex-direction:column;gap:6px}
  #debugBox{position:fixed;right:10px;top:10px;background:#08121acc;color:#9fb3c7;padding:8px;border-radius:8px;font-size:12px;z-index:21;max-width:360px;max-height:70vh;overflow:auto;white-space:pre-wrap}
  #diagCanvas{position:fixed;right:10px;bottom:10px;width:160px;height:120px;border:2px solid #223449;border-radius:8px;z-index:22;background:#000}
</style>
</head>
<body>
<div id="ui">
  <div style="font-size:15px;margin-bottom:6px"><b>Single‑Sphere Binocular Trainer</b> — 프리미티브 + 2D 이미지 평면(L/R 업로드)</div>

  <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px">
    <button id="btnStart">▶ Start Preview (SxS)</button>
    <button id="btnStop">⏸ Pause</button>
    <label>미리보기
      <select id="previewMode">
        <option value="sbs" selected>Side‑by‑Side (PC)</option>
        <option value="mono">단일 뷰 (디버그)</option>
      </select>
    </label>
  </div>

  <fieldset style="margin-top:8px">
    <legend>보기 거리 (VR/PC 공통)</legend>
    <label>거리 (m)
      <input id="distanceMeters" type="range" min="1" max="10" step="0.1" value="4">
    </label>
    <div class="muted small">VR에서는 카메라 대신 <i>장면</i>을 이동시켜 거리를 조절합니다. (컨트롤러 스틱도 지원)</div>
  </fieldset>

  <fieldset style="margin-top:8px">
    <legend>소스 선택</legend>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <label>소스
        <select id="source" style="min-width:260px">
          <option value="primitive" selected>Primitive (프리미티브)</option>
          <option value="image_pair">Uploaded Image (L/R 이미지)</option>
        </select>
      </label>

      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <div class="col">
          <label>왼쪽 이미지 업로드 (2D)
            <input id="uploadImageL" type="file" accept=".jpg,.jpeg,.png">
          </label>
          <div id="uploadedL" class="upload-list muted">왼쪽 이미지 없음</div>
        </div>

        <div class="col">
          <label>오른쪽 이미지 업로드 (2D)
            <input id="uploadImageR" type="file" accept=".jpg,.jpeg,.png">
          </label>
          <div id="uploadedR" class="upload-list muted">오른쪽 이미지 없음</div>
        </div>

        <div style="display:flex;flex-direction:column;gap:6px;margin-left:6px">
          <label style="align-items:center"><input id="usePerEyeTexturesOption" type="checkbox"> Use per-eye primitive textures</label>
          <div class="muted small">이미지 페어 선택 시 좌/우 이미지를 업로드하세요.</div>
        </div>
      </div>
    </div>
  </fieldset>

  <fieldset style="margin-top:8px">
    <legend>프리미티브</legend>
    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px">
      <label>모양
        <select id="primitive">
          <option value="sphere" selected>Sphere</option>
          <option value="box">Box</option>
          <option value="cylinder">Cylinder</option>
          <option value="plane">Plane</option>
        </select>
      </label>
      <label>크기(scale) <input id="primSize" type="range" min="0.2" max="2" step="0.01" value="0.9"></label>
      <label>자동회전 <input id="autoRotate" type="checkbox" checked></label>
    </div>
  </fieldset>

  <fieldset style="margin-top:8px">
    <legend>텍스쳐 & 필터 (프리미티브 전용 / 좌/우)</legend>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
      <label>좌 텍스쳐
        <input id="texL" type="file" accept=".jpg,.jpeg,.png">
      </label>
      <label>우 텍스쳐
        <input id="texR" type="file" accept=".jpg,.jpeg,.png">
      </label>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:6px">
      <div style="border:1px solid #2b435f;border-radius:10px;padding:8px">
        <div style="font-weight:600;color:#ffb3b3;margin-bottom:4px">Left</div>
        <label>Luminance <input id="lumL" type="range" min="0.2" max="2" step="0.01" value="1.0"></label>
        <label>Contrast  <input id="conL" type="range" min="0" max="2" step="0.01" value="1.0"></label>
      </div>
      <div style="border:1px solid #2b435f;border-radius:10px;padding:8px">
        <div style="font-weight:600;color:#b3e6ff;margin-bottom:4px">Right</div>
        <label>Luminance <input id="lumR" type="range" min="0.2" max="2" step="0.01" value="1.0"></label>
        <label>Contrast  <input id="conR" type="range" min="0" max="2" step="0.01" value="1.0"></label>
      </div>
    </div>
  </fieldset>

  <fieldset style="margin-top:8px">
    <legend>팝아웃 (Up / Hold / Down 루프)</legend>
    <div id="popControls">
      <label>팝 대상<select id="popEye"><option value="L">Left</option><option value="R">Right</option></select></label>
      <label>팝 거리 (m) <input id="popAmount" type="range" min="0" max="0.6" step="0.005" value="0.08"></label>
      <label>올라가는 시간 (s) <input id="popTime" type="number" min="0.01" step="0.01" value="0.45" style="width:80px"></label>
      <label>유지 시간 (s) <input id="holdTime" type="number" min="0" step="0.01" value="0.6" style="width:80px"></label>
      <div id="popStatus">idle</div>
    </div>
  </fieldset>

  <fieldset style="margin-top:8px">
    <legend>약시 훈련 모드</legend>
    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px">
      <label>약시안
        <select id="ambEye">
          <option value="L">Left</option>
          <option value="R">Right</option>
        </select>
      </label>
      <label>모드
        <select id="therapyMode">
          <option value="off" selected>Off</option>
          <option value="swap">Swap Blink (우세안에 잠깐 표시)</option>
          <option value="disparity">Disparity Pop (앞으로 튀어나오기)</option>
        </select>
      </label>
      <label>주기 (s)
        <input id="thermPeriod" type="number" min="0.2" step="0.1" value="2.0">
      </label>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;margin-top:6px">
      <label>듀티(ON 비율 0~1)
        <input id="thermDuty" type="number" min="0.05" max="0.95" step="0.05" value="0.3">
      </label>
      <label>Disparity 유지 (s)
        <input id="disparityHold" type="number" min="0" step="0.1" value="0.8">
      </label>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <button id="audioToggle" type="button">🔔 Audio Cue: Off</button>
        <button id="audioTest" type="button">Test</button>
      </div>
    </div>

    <div style="display:flex;gap:12px;align-items:center;margin-top:8px">
      <label style="display:flex;align-items:center;gap:6px"><input id="ambBoost" type="checkbox"> 약시안 Brighten (ambBoost)</label>
      <div class="muted small">* Swap Blink: 약시 이미지를 우세안 디스플레이에 잠깐 보여줬다가 숨깁니다. Disparity Pop: 약시안 대상이 전방으로 팝아웃됩니다. 오디오 큐는 팝 시작 시 1회 짧게 재생됩니다.</div>
    </div>
  </fieldset>

  <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;margin-top:8px">
    <button id="enterVR">Enter VR</button>
    <button id="exitVR">Exit VR</button>
    <button id="runDiag">Run Diagnostics</button>
  </div>
</div>

<div id="sbsLabels"><span class="pill L">LEFT</span><span class="pill R">RIGHT</span></div>
<canvas id="webgl"></canvas>
<div id="hud">—</div>
<div id="debugBox" aria-hidden="false">ready</div>
<!-- diagnostic canvas for a raw GL test -->
<canvas id="diagCanvas" width="160" height="120" style="display:none"></canvas>

<!-- three.js 로컬 우선, 실패 시 CDN 폴백 -->
<script src="./three.min.js"></script>
<script>
  if(!window.THREE){
    var s=document.createElement('script');
    s.src='https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js';
    s.onload=function(){ console.log('[three] loaded from CDN'); };
    s.onerror=function(){ console.error('[three] CDN load failed'); };
    document.head.appendChild(s);
  }
</script>
<script>
(function(){
  'use strict';
  const $ = id => document.getElementById(id);
  const debugBox = $('debugBox');
  function dbg(s){ debugBox.textContent = String(s); console.log(s); }
  (function(){ function netDbg(){ const on = navigator.onLine; const m = on ? 'online' : 'offline — CDN/요청 실패 가능'; dbg('[net] '+m); } window.addEventListener('online', netDbg); window.addEventListener('offline', netDbg); try{ netDbg(); }catch(e){} })();

  // Renderer + scene
  const canvas = $('webgl');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
  renderer.xr.enabled = true;
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.domElement.style.touchAction = 'none';
  if(renderer.xr.setReferenceSpaceType) renderer.xr.setReferenceSpaceType('local-floor');

  function fit(){ const dpr=Math.min(2,window.devicePixelRatio||1); renderer.setPixelRatio(dpr); renderer.setSize(window.innerWidth, window.innerHeight, false); }
  window.addEventListener('resize', fit);
  fit();

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x101218);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 100);
  camera.position.set(0,0,2.2);

  const amb = new THREE.AmbientLight(0xffffff, 0.9); scene.add(amb);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(3,5,4); scene.add(dir);
  const lightDir = new THREE.Vector3().copy(dir.position).normalize();

  const stage = new THREE.Group(); scene.add(stage);
  const fusionGroup = new THREE.Group(); stage.add(fusionGroup);

  const LAYER_L = 1, LAYER_R = 2;

  let meshL = null, meshR = null;
  let uploadedL = null, uploadedR = null;
  const texLoader = new THREE.TextureLoader(); texLoader.setCrossOrigin('anonymous');

  function commonUniforms(){ return {
    uMap:{value:null}, uHasMap:{value:0},
    uLum:{value:1.0}, uCon:{value:1.0}, uTint:{value:new THREE.Vector3(0,0,0)},
    uLightDir:{value:lightDir.clone()}, uBaseColor:{value:new THREE.Color(0xffffff)}, uGamma:{value:2.2}
  }; }
  const vert = `varying vec2 vUv; varying vec3 vN; void main(){ vUv=uv; vN=normalize(normalMatrix*normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`;
  const frag = `
    uniform sampler2D uMap; uniform int uHasMap; uniform float uLum, uCon, uGamma; uniform vec3 uTint; uniform vec3 uLightDir; uniform vec3 uBaseColor;
    varying vec2 vUv; varying vec3 vN;
    float satf(float x){ return clamp(x,0.0,1.0); }
    vec3 rgb2hsv(vec3 c){ float cmax=max(c.r,max(c.g,c.b)); float cmin=min(c.r,min(c.g,c.b)); float d=cmax-cmin; float h=0.0;
      if(d>1e-5){ if(cmax==c.r) h=mod((c.g-c.b)/d,6.0); else if(cmax==c.g) h=(c.b-c.r)/d+2.0; else h=(c.r-c.g)/d+4.0; }
      float s=cmax==0.0?0.0:d/cmax; return vec3(60.0*h,s,cmax);
    }
    vec3 hsv2rgb(vec3 h){ float H=h.x/60.0; float S=h.y; float V=h.z; float C=V*S; float X=C*(1.0-abs(mod(H,2.0)-1.0)); vec3 rgb=(H<1.0?vec3(C,X,0.0):H<2.0?vec3(X,C,0.0):H<3.0?vec3(0.0,C,X):H<4.0?vec3(0.0,X,C):H<5.0?vec3(X,0.0,C):vec3(C,0.0,X)); float m=V-C; return rgb+vec3(m); }
    void main(){
      vec3 base = uHasMap==1 ? texture2D(uMap,vUv).rgb : uBaseColor;
      base = (base-0.5)*uCon + 0.5;
      base *= uLum;
      if(uTint.z>0.001){ vec3 hv=rgb2hsv(base); hv.x = mod(uTint.x,360.0); hv.y = clamp(hv.y+uTint.y,0.0,1.0); vec3 tc=hsv2rgb(hv); base = mix(base,tc,clamp(uTint.z,0.0,1.0)); }
      float lam = max(0.0, dot(normalize(vN), normalize(uLightDir)));
      vec3 col = base * (0.35 + 0.65 * lam);
      col = pow(col, vec3(1.0/uGamma));
      gl_FragColor = vec4(satf(col.r), satf(col.g), satf(col.b), 1.0);
    }
  `;
  function makePrimitiveMaterial(){ return new THREE.ShaderMaterial({uniforms:commonUniforms(), vertexShader:vert, fragmentShader:frag, lights:false, fog:false, transparent:false, side:THREE.DoubleSide}); }

  function buildPrimitiveGeo(kind,size){
    const s = Math.max(0.05,size);
    switch(kind){
      case 'sphere': return new THREE.SphereGeometry(s*0.5,64,40);
      case 'box': return new THREE.BoxGeometry(s,s,s);
      case 'cylinder': return new THREE.CylinderGeometry(s*0.5,s*0.5,s,64,1,false);
      case 'plane': return new THREE.PlaneGeometry(s,s,1,1);
      default: return new THREE.SphereGeometry(s*0.5,64,40);
    }
  }

  function disposeMesh(m){
    if(!m) return;
    try{ if(m.geometry) m.geometry.dispose(); }catch(e){}
    if(m.material){ if(Array.isArray(m.material)) m.material.forEach(x=>{ try{x.dispose();}catch(e){} }); else try{ m.material.dispose(); }catch(e){} }
  }

  function clearFusion(){
    if(meshL){ fusionGroup.remove(meshL); disposeMesh(meshL); meshL=null; }
    if(meshR){ fusionGroup.remove(meshR); disposeMesh(meshR); meshR=null; }
  }

  function buildFusionFromPrimitive(kind,size){
    clearFusion();
    const geo = buildPrimitiveGeo(kind,size);
    const matL = makePrimitiveMaterial(), matR = makePrimitiveMaterial();
    meshL = new THREE.Mesh(geo, matL); meshL.layers.set(LAYER_L); meshL.position.x = -0.03;
    meshR = new THREE.Mesh(geo.clone ? geo.clone() : geo, matR); meshR.layers.set(LAYER_R); meshR.position.x = 0.03;
    meshL.userData.basePos = meshL.position.clone(); meshR.userData.basePos = meshR.position.clone();
    fusionGroup.add(meshL); fusionGroup.add(meshR);
  }

  function buildFusionFromImagePair(){
    clearFusion();
    const primSize = +$('primSize').value || 0.9;
    const leftMeta = uploadedL, rightMeta = uploadedR;
    if(!leftMeta && !rightMeta){ dbg('왼쪽 또는 오른쪽 이미지를 업로드하세요.'); return; }
    function makePlaneFromMeta(meta){
      const aspect = (meta && meta.width && meta.height) ? (meta.width/meta.height) : 1.0;
      const h = primSize; const w = primSize * aspect;
      const geo = new THREE.PlaneGeometry(w,h);
      const mat = new THREE.MeshBasicMaterial({ map: meta ? texLoader.load(meta.url, (tx)=>{ try{ tx.encoding = THREE.sRGBEncoding; }catch(e){} }, undefined, ()=>{} ) : null, side: THREE.DoubleSide });
      return {geo,mat};
    }
    const left = makePlaneFromMeta(leftMeta), right = makePlaneFromMeta(rightMeta);
    meshL = new THREE.Mesh(left.geo, left.mat); meshL.layers.set(LAYER_L); meshL.userData.isImagePlane = true; meshL.position.x = -0.03; meshL.userData.basePos = meshL.position.clone();
    meshR = new THREE.Mesh(right.geo, right.mat); meshR.layers.set(LAYER_R); meshR.userData.isImagePlane = true; meshR.position.x = 0.03; meshR.userData.basePos = meshR.position.clone();
    fusionGroup.add(meshL); fusionGroup.add(meshR);
  }

  // Upload handlers
  $('uploadImageL').addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    if(!f.name.match(/\.(jpe?g|png)$/i)){ dbg('JPG/JPEG/PNG만 지원합니다'); return; }
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = ()=>{ uploadedL = {url, width: img.naturalWidth, height: img.naturalHeight, name: f.name}; $('uploadedL').textContent = f.name; if($('source').value === 'image_pair') buildFusionFromImagePair(); };
    img.onerror = ()=>{ dbg('왼쪽 이미지 로드 실패'); URL.revokeObjectURL(url); };
    img.src = url;
  });
  $('uploadImageR').addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    if(!f.name.match(/\.(jpe?g|png)$/i)){ dbg('JPG/JPEG/PNG만 지원합니다'); return; }
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = ()=>{ uploadedR = {url, width: img.naturalWidth, height: img.naturalHeight, name: f.name}; $('uploadedR').textContent = f.name; if($('source').value === 'image_pair') buildFusionFromImagePair(); };
    img.onerror = ()=>{ dbg('오른쪽 이미지 로드 실패'); URL.revokeObjectURL(url); };
    img.src = url;
  });

  // controls
  $('source').addEventListener('change', ()=>{ if($('source').value==='primitive') buildFusionFromPrimitive($('primitive').value, +$('primSize').value); else buildFusionFromImagePair(); });
  $('primitive').addEventListener('change', ()=>{ if($('source').value==='primitive') buildFusionFromPrimitive($('primitive').value, +$('primSize').value); });
  $('primSize').addEventListener('input', ()=>{ if($('source').value==='primitive') buildFusionFromPrimitive($('primitive').value, +$('primSize').value); else buildFusionFromImagePair(); });

  function setPrimitiveTexture(eye, file){
    if(!file) return;
    const reader = new FileReader();
    reader.onload = ()=> {
      const url = reader.result;
      texLoader.load(url, (tex)=>{
        try{ tex.encoding = THREE.sRGBEncoding; }catch(e){}
        tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
        tex.minFilter = THREE.LinearMipMapLinearFilter; tex.magFilter = THREE.LinearFilter; tex.generateMipmaps = true; tex.needsUpdate = true;
        if($('usePerEyeTexturesOption').checked){
          const target = eye === 'L' ? meshL : meshR;
          if(!target){ console.warn('대상 메쉬 없음'); return; }
          if(target.material && target.material.uniforms){
            target.material.uniforms.uMap.value = tex; target.material.uniforms.uHasMap.value = 1; target.material.needsUpdate = true;
          } else if(target.material){
            target.material.map = tex; target.material.needsUpdate = true;
          }
        } else {
          dbg('Use per-eye primitive textures 옵션이 꺼져 있습니다. 옵션을 켜면 프리미티브에 적용됩니다.');
        }
      }, undefined, (err)=>{ console.error(err); dbg('텍스쳐 로드 실패'); });
    };
    reader.readAsDataURL(file);
  }
  $('texL').addEventListener('change', (e)=>{ const f = e.target.files && e.target.files[0]; if(f) setPrimitiveTexture('L', f); });
  $('texR').addEventListener('change', (e)=>{ const f = e.target.files && e.target.files[0]; if(f) setPrimitiveTexture('R', f); });

  // ===== 거리 조절 =====
  function applyDistance(m){
    const d = Math.min(10, Math.max(0.5, m||4));
    stage.position.z = -d;
    $('hud').textContent = `distance: ${d.toFixed(2)}m`;
    camera.near = Math.max(0.01, d * 0.001);
    camera.far = Math.max(10, d * 20);
    camera.updateProjectionMatrix();
  }
  $('distanceMeters').addEventListener('input', e=> applyDistance(parseFloat(e.target.value)) );

  // Pop loop
  let running=false, lastT=performance.now(), popClock=0;
  let popState = 'idle', prevPopState = 'idle';
  function updatePop(dt){
    const popTime = Math.max(0.0001, +$('popTime').value);
    const holdTime = Math.max(0, +$('holdTime').value);
    const cycle = popTime + holdTime + popTime;
    if(cycle <= 0.0001 || (!meshL && !meshR)){ $('popStatus').textContent = 'idle'; return; }
    popClock += dt;
    const t = popClock % cycle;
    let state='idle', curAmount=0; prevPopState = popState;
    if(t < popTime){ state='up'; const p = t/popTime; const ease=(1 - Math.cos(Math.PI * p))/2; curAmount = ease * +$('popAmount').value; }
    else if(t < popTime + holdTime){ state='hold'; curAmount = +$('popAmount').value; }
    else { state='down'; const q = (t - popTime - holdTime)/popTime; curAmount = (1 - q) * +$('popAmount').value; }
    $('popStatus').textContent = state; popState = state; if(popState!==prevPopState){ onPopStateChange(popState); }

    const stageWorld = stage.getWorldPosition(new THREE.Vector3());
    const camWorldPos = camera.getWorldPosition(new THREE.Vector3());
    const dir = camWorldPos.sub(stageWorld).normalize();
    const worldTarget = stageWorld.clone().add(dir.multiplyScalar(curAmount));
    const localTarget = stage.worldToLocal(worldTarget.clone());

    const popEye = $('popEye').value;
    if(meshL){
      const baseL = meshL.userData.basePos || new THREE.Vector3();
      if(popEye === 'L') meshL.position.copy(baseL).add(localTarget); else meshL.position.copy(baseL);
    }
    if(meshR){
      const baseR = meshR.userData.basePos || new THREE.Vector3();
      if(popEye === 'R') meshR.position.copy(baseR).add(localTarget); else meshR.position.copy(baseR);
    }
  }

  // === 약시 훈련 모드 ===
  let therapyClock = 0;
  function restoreNormalLayers(){ if(meshL) meshL.layers.set(LAYER_L); if(meshR) meshR.layers.set(LAYER_R); }
  function applyTherapy(dt){
    const mode   = $('therapyMode').value;
    const ambEye = $('ambEye').value;
    therapyClock += dt;

    if (mode === 'swap') {
      const period = Math.max(0.2, +$('thermPeriod').value || 2.0);
      const duty   = Math.min(0.95, Math.max(0.05, +$('thermDuty').value || 0.3));
      const on = (therapyClock % period) < (period * duty);
      const amb = (ambEye === 'L') ? meshL : meshR;
      const dom = (ambEye === 'L') ? meshR : meshL;
      if (amb && dom){
        if(on){
          amb.layers.mask = (1<<LAYER_L) | (1<<LAYER_R);
          dom.layers.mask = 0;
        } else {
          restoreNormalLayers();
        }
      }
    } else if (mode === 'disparity') {
      $('popEye').value = (ambEye==='L') ? 'L' : 'R';
      const dispHold = Math.max(0, +$('disparityHold').value || +$('holdTime').value);
      if (+$('holdTime').value !== dispHold) $('holdTime').value = String(dispHold);

      const ambBoostEl = $('ambBoost');
      if(ambBoostEl && ambBoostEl.checked){
        try{
          if(ambEye==='L' && meshL && meshL.material && meshL.material.uniforms){ meshL.material.uniforms.uLum.value=1.2; meshL.material.uniforms.uCon.value=1.1; }
          if(ambEye==='R' && meshR && meshR.material && meshR.material.uniforms){ meshR.material.uniforms.uLum.value=1.2; meshR.material.uniforms.uCon.value=1.1; }
          if(ambEye==='L' && meshR && meshR.material && meshR.material.uniforms){ meshR.material.uniforms.uLum.value=0.95; meshR.material.uniforms.uCon.value=0.95; }
          if(ambEye==='R' && meshL && meshL.material && meshL.material.uniforms){ meshL.material.uniforms.uLum.value=0.95; meshL.material.uniforms.uCon.value=0.95; }
        }catch(e){ console.warn('ambBoost apply failed', e); }
      } else {
        try{
          if(meshL && meshL.material && meshL.material.uniforms){ meshL.material.uniforms.uLum.value=1.0; meshL.material.uniforms.uCon.value=1.0; }
          if(meshR && meshR.material && meshR.material.uniforms){ meshR.material.uniforms.uLum.value=1.0; meshR.material.uniforms.uCon.value=1.0; }
        }catch(e){}
      }
    } else {
      restoreNormalLayers();
      try{
        if(meshL && meshL.material && meshL.material.uniforms){ meshL.material.uniforms.uLum.value=1.0; meshL.material.uniforms.uCon.value=1.0; }
        if(meshR && meshR.material && meshR.material.uniforms){ meshR.material.uniforms.uLum.value=1.0; meshR.material.uniforms.uCon.value=1.0; }
      }catch(e){}
    }
  }

  // Render loop (non-XR)
  function renderLoop(t){
    if(!running) return;
    const dt = (t - lastT)/1000; lastT = t;

    if($('source').value === 'image_pair'){
      if(meshL && meshL.userData.isImagePlane) meshL.quaternion.copy(camera.quaternion);
      if(meshR && meshR.userData.isImagePlane) meshR.quaternion.copy(camera.quaternion);
    } else {
      if($('autoRotate').checked) fusionGroup.rotation.y += dt * (+$('primSize') || 0.4);
    }

    updatePop(dt);
    applyTherapy(dt);

    const w = renderer.domElement.width, h = renderer.domElement.height;
    renderer.setScissorTest(false); renderer.clear();

    if($('previewMode').value === 'sbs'){
      const half = Math.max(1, w >> 1);
      camera.aspect = half/h; camera.updateProjectionMatrix();
      renderer.setScissorTest(true);
      renderer.setViewport(0,0,half,h); renderer.setScissor(0,0,half,h);
      camera.layers.set(LAYER_L); renderer.render(scene, camera);
      renderer.setViewport(half,0,half,h); renderer.setScissor(half,0,half,h);
      camera.layers.set(LAYER_R); renderer.render(scene, camera);
      camera.layers.set(0);
      renderer.setScissorTest(false);
    } else {
      camera.aspect = w/h; camera.updateProjectionMatrix();
      renderer.setViewport(0,0,w,h);
      camera.layers.mask = (1<<LAYER_L) | (1<<LAYER_R);
      renderer.render(scene, camera);
      camera.layers.set(0);
    }

    requestAnimationFrame(renderLoop);
  }

  $('btnStart').addEventListener('click', ()=>{ if(!running){ running=true; lastT=performance.now(); requestAnimationFrame(renderLoop); dbg('Preview started'); }});
  $('btnStop').addEventListener('click', ()=>{ running=false; dbg('Preview paused'); });

  // XR entry (robust, Quest-friendly)
  let xrSession = null;
  $('enterVR').addEventListener('click', async ()=>{
    function show(msg){ dbg(msg); console.log('[enterVR] '+msg); }
    try{
      // Quick environment hints
      show('enterVR 버튼 클릭 - 시작. secureContext=' + window.isSecureContext + ' url=' + location.href);
      if(!window.isSecureContext){
        show('경고: WebXR은 https 또는 localhost에서만 동작할 수 있습니다. (파일:// 불가)');
        // still attempt to continue if browser allows (some headsets allow)
      }
      if(!navigator.xr){ show('navigator.xr 존재하지 않음 — 브라우저가 WebXR을 지원하지 않습니다.'); return; }

      const supportsVR = await navigator.xr.isSessionSupported('immersive-vr').catch(e=>{ show('isSessionSupported(immersive-vr) 에러: '+e); return false; });
      const supportsAR = await navigator.xr.isSessionSupported('immersive-ar').catch(e=>{ show('isSessionSupported(immersive-ar) 에러: '+e); return false; });
      show('supports: immersive-vr=' + supportsVR + ' immersive-ar=' + supportsAR);

      if(!supportsVR && !supportsAR){ show('기기에서 immersive-vr/immersive-ar 모두 미지원'); return; }

      // Try different option sets because some runtimes reject optionalFeatures.
      const tries = [
        { optionalFeatures: ['local-floor','bounded-floor','hand-tracking','layers'] },
        { optionalFeatures: ['local-floor','layers'] },
        { optionalFeatures: ['local-floor'] },
        {}
      ];

      let session = null, lastErr = null;
      for(const opts of tries){
        try{
          show('requestSession 시도: ' + JSON.stringify(opts));
          session = await navigator.xr.requestSession('immersive-vr', opts);
          if(session){ show('immersive-vr 세션 획득 성공'); break; }
        }catch(err){
          lastErr = err;
          show('requestSession 실패: ' + (err && err.message ? err.message : String(err)));
        }
      }

      if(!session && supportsAR){
        try{
          show('immersive-vr 실패 — immersive-ar 시도');
          session = await navigator.xr.requestSession('immersive-ar', { optionalFeatures:['local-floor'] });
          show('immersive-ar 세션 획득 성공');
        }catch(err){
          lastErr = err;
          show('immersive-ar 실패: ' + (err && err.message ? err.message : String(err)));
        }
      }

      if(!session){
        show('모든 requestSession 시도 실패. 마지막 에러: ' + (lastErr && lastErr.message ? lastErr.message : String(lastErr)));
        return;
      }

      // Attach session to three.js renderer
      try{
        await renderer.xr.setSession(session);
        xrSession = session;
        lastT = performance.now();

        // animation loop for XR
        renderer.setAnimationLoop((now)=>{
          const dt = (now - lastT) / 1000; lastT = now;

          try{
            for(const src of xrSession.inputSources){
              if(!src.gamepad) continue;
              const g = src.gamepad;
              const axesY = (g.axes && g.axes.length>=2) ? g.axes[g.axes.length-1] : 0;
              const dead = 0.18;
              const y = Math.abs(axesY) > dead ? axesY : 0;
              if(y){
                const cur = parseFloat($('distanceMeters').value);
                const speed = 2.2;
                const next = Math.min(10, Math.max(1, cur + (-y)*speed*dt));
                if(Math.abs(next-cur) > 1e-3){ $('distanceMeters').value = next.toFixed(2); applyDistance(next); }
              }
            }
          }catch(e){}

          if(running) updatePop(dt);
          if($('source').value === 'image_pair'){
            const xrCamNow = renderer.xr.getCamera ? renderer.xr.getCamera(camera) : camera;
            const quat = (xrCamNow && xrCamNow.quaternion) ? xrCamNow.quaternion : camera.quaternion;
            if(meshL && meshL.userData.isImagePlane) meshL.quaternion.copy(quat);
            if(meshR && meshR.userData.isImagePlane) meshR.quaternion.copy(quat);
          } else {
            if($('autoRotate').checked) fusionGroup.rotation.y += dt * (+$('primSize') || 0.4);
          }

          // Per-eye layer enforcement (ArrayCamera)
          const xrCam = renderer.xr.getCamera ? renderer.xr.getCamera(camera) : null;
          if(xrCam && xrCam.isArrayCamera && xrCam.cameras && xrCam.cameras.length>=2){
            const leftCam  = xrCam.cameras[0];
            const rightCam = xrCam.cameras[1];
            if(leftCam && leftCam.layers) leftCam.layers.set(LAYER_L);
            if(rightCam && rightCam.layers) rightCam.layers.set(LAYER_R);
          }

          applyTherapy(dt);
          renderer.render(scene, camera);
        });

        session.addEventListener('end', ()=>{ renderer.setAnimationLoop(null); xrSession=null; lastT = performance.now(); show('XR session 종료됨'); });
        show('XR 세션이 시작되었습니다. HMD에서 프롬프트(권한)가 보이는지 확인하세요.');
      }catch(err){
        show('renderer.xr.setSession 중 에러: ' + (err && err.message ? err.message : String(err)));
        try{ if(session) await session.end(); }catch(e){}
      }
    }catch(e){
      dbg('enterVR 예외: ' + (e && e.message ? e.message : String(e)));
    }
  });

  $('exitVR').addEventListener('click', async ()=>{ try{ if(xrSession) await xrSession.end(); }catch(e){ console.warn('XR 세션 종료 실패', e); dbg('XR end error: '+e); } });

  // Ensure camera sees both L/R by default
  camera.layers.enable(LAYER_L); camera.layers.enable(LAYER_R);

  const fallbackGeo = new THREE.SphereGeometry(0.12, 32, 20);
  const fallbackMat = new THREE.MeshStandardMaterial({color:0x8888ff, metalness:0.1, roughness:0.7});
  const fallback = new THREE.Mesh(fallbackGeo, fallbackMat);
  fallback.position.set(0, -0.15, -0.9);
  fallback.userData._isFallback = true;
  stage.add(fallback);

  buildFusionFromPrimitive('sphere', +$('primSize').value);
  applyDistance(parseFloat($('distanceMeters').value));

  try{ renderer.render(scene, camera); dbg('Initial frame rendered.'); }
  catch(e){ dbg('Initial render failed: ' + (e && e.message)); console.error(e); }

  running = true; lastT = performance.now(); requestAnimationFrame(renderLoop);

  // Diagnostics
  function runRawGLTest(){
    const diag = $('diagCanvas');
    diag.style.display = 'block';
    const gl = diag.getContext('webgl2') || diag.getContext('webgl') || diag.getContext('experimental-webgl');
    if(!gl) return {ok:false, msg:'WebGL context not available for diag canvas'};
    gl.clearColor(0.1, 0.2, 0.6, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    return {
      ok:true,
      glVersion: gl.getParameter(gl.VERSION),
      shadingLang: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
      vendor: gl.getParameter(gl.VENDOR),
      renderer: gl.getParameter(gl.RENDERER),
      maxTexSize: gl.getParameter(gl.MAX_TEXTURE_SIZE)
    };
  }

  function dumpDiagnostics(){
    try{
      const out = [];
      out.push('--- Diagnostics snapshot ---');
      out.push('canvas size (css): ' + (canvas.width/ (window.devicePixelRatio||1)).toFixed(1) + 'x' + (canvas.height/ (window.devicePixelRatio||1)).toFixed(1) + ' (physical: ' + canvas.width + 'x' + canvas.height + ')');
      let glInfo = {};
      try{
        const gl = renderer.getContext();
        glInfo = {
          version: gl.getParameter(gl.VERSION),
          sl: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
          vendor: gl.getParameter(gl.VENDOR),
          renderer: gl.getParameter(gl.RENDERER),
          maxTexSize: gl.getParameter(gl.MAX_TEXTURE_SIZE)
        };
      }catch(e){ out.push('renderer.getContext() failed: ' + e.message); }
      out.push('GL: ' + JSON.stringify(glInfo));
      out.push('three.renderer.info: ' + JSON.stringify(renderer.info));
      out.push('camera pos: ' + camera.position.toArray().map(n=>n.toFixed(3)).join(', ') + ' layersMask:' + camera.layers.mask);
      out.push('camera near/far: ' + camera.near + '/' + camera.far + ' fov:' + camera.fov);
      out.push('scene.children count: ' + scene.children.length);
      scene.children.forEach((c,i)=>{
        try{
          const typ = c.type || c.constructor && c.constructor.name;
          const pos = c.position ? c.position.toArray().map(n=>n.toFixed(3)).join(',') : '';
          out.push(`${i}: ${typ} name=${c.name||''} visible=${c.visible} pos=[${pos}]`);
        }catch(e){}
      });
      function meshInfo(m, name){
        if(!m) return `${name}: (null)`;
        const matType = m.material ? (m.material.type || (m.material.constructor && m.material.constructor.name) || 'mat') : 'no-material';
        const map = (m.material && (m.material.map || (m.material.uniforms && m.material.uniforms.uHasMap && m.material.uniforms.uHasMap.value===1))) ? 'hasMap' : 'noMap';
        return `${name}: pos=${m.position.toArray().map(n=>n.toFixed(3)).join(',')} visible=${m.visible} layers=${m.layers.mask} type=${matType} ${map}`;
      }
      out.push(meshInfo(meshL,'meshL'));
      out.push(meshInfo(meshR,'meshR'));
      out.push('fallback present: ' + (fallback && fallback.parent ? 'yes' : 'no'));
      const raw = runRawGLTest();
      out.push('rawGL test: ' + JSON.stringify(raw));
      const txt = out.join('\n');
      dbg(txt);
      return txt;
    }catch(e){
      dbg('Diagnostics failed: ' + (e && e.message));
      return 'Diagnostics exception: ' + (e && e.message);
    }
  }

  // Audio
  let audioCtx = null, audioOn = false;
  function ensureAudio(){ if(!audioCtx){ const AC = window.AudioContext||window.webkitAudioContext; if(AC) audioCtx = new AC(); } }
  function beep(ms=120, freq=880){ if(!audioOn) return; ensureAudio(); if(!audioCtx) return; const t0 = audioCtx.currentTime; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.frequency.value = freq; osc.type = 'sine'; gain.gain.setValueAtTime(0.0001, t0); gain.gain.exponentialRampToValueAtTime(0.3, t0+0.01); gain.gain.exponentialRampToValueAtTime(0.0001, t0 + ms/1000); osc.connect(gain).connect(audioCtx.destination); osc.start(t0); osc.stop(t0 + ms/1000 + 0.05); }
  $('audioToggle').addEventListener('click', ()=>{ audioOn = !audioOn; $('audioToggle').textContent = (audioOn?'🔔 Audio Cue: On':'🔔 Audio Cue: Off'); if(audioOn) { ensureAudio(); beep(80, 1200); } });
  $('audioTest').addEventListener('click', ()=>{ ensureAudio(); audioOn = true; $('audioToggle').textContent='🔔 Audio Cue: On'; beep(120, 1000); });

  function onPopStateChange(newState){
    if($('therapyMode').value==='disparity' && newState==='hold') beep(120, 1000);
  }

  window.appDiagnostics = { dump: dumpDiagnostics, runRawGLTest };
  $('runDiag').addEventListener('click', ()=>{ const r = dumpDiagnostics(); dbg('Diagnostics output printed to Debug box and Console.'); });

})();
</script>
</body>
</html>